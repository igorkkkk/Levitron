

struct PID_s {
   float field = 0;       // значение с датчика Холла
    int ref = 0; // Задание (потенциометр на третьей ноге)
    float fieldm = 0;       // значение с датчика Холла
    int refm= 0; // Задание (потенциометр на третьей ноге)
    float error = 0;     // Ошибка управления
    int control = 0;     // Сигнал управления
    float integral = 0;    // интегральная составляющая
    float diff = 0;
    float prevField = 0;
    float prevRef = 0;
    float prevError = 0;
    float k = 0;
    float p = 0;
    float i = 0;
    float d = 0;
};
    PID_s pidZ;

void control_f(int &control, const int pinPWM, const int dir1, const int dir2);

void computePID_f(PID_s &pid,float deltaTime, float K);


void measure_f(int &sensorV, const int pin, char num);


//const int A_PinZ = A0;
//const int A_PinZRef = A2;
const int PWM_PinZ = 6;
const int D_Pin1Z = 8;
const int D_Pin2Z = 7;

char flag = 0;
unsigned int newData = 0;
int prevData = 0;

void setup() {
    // initialize serial communications at 115200 bps:
    Serial.begin(115200);
    pinMode(D_Pin1Z, OUTPUT);
    pinMode(D_Pin2Z, OUTPUT);
pinMode(13, OUTPUT);

    pidZ.k = 1;
    pidZ.p = -5.25;
    pidZ.i = -0;
    pidZ.d = -160;
    cli();//disable interrupts

  
  //clear ADCSRA and ADCSRB registers
  ADCSRA = 0;
  ADCSRB = 0;
  ADMUX = (1 << REFS1); //set reference voltage
  
 ADMUX |= (0 << ADLAR); //left align the ADC value- so we can read highest 8 bits from ADCH register only
  
  ADCSRA |= (1 << ADPS2) | (1 << ADPS0) |(1 << ADPS1); //set ADC clock with 32 prescaler- 16mHz/32=500kHz
  ADCSRA |= (1 << ADATE); //enabble auto trigger
  ADCSRA |= (1 << ADIE); //enable interrupts when measurement complete
  ADCSRA |= (1 << ADEN); //enable ADC
  ADCSRA |= (1 << ADSC); //start ADC measurements

      TCCR1A = 0; // установить регистры в 0
    TCCR1B = 0; 

    OCR1A = 128; // установка регистра совпадения
    TCCR1B |= (1 << WGM12); // включение в CTC режим

    // Установка битов CS10 и CS12 на коэффициент деления 1024
    TCCR1B |= (1 << CS10);
   TCCR1B |= (1 << CS11);

    TIMSK1 |= (1 << OCIE1A);  // включение прерываний по совпадению

//    TCCR3B = 0b00000001;  // x8
//TCCR3A = 0b00000011;  // fast pwm
TCCR3A = (1 << COM3A1) | (1 << WGM30) | (1 << WGM31);
TCCR3B = (1 << WGM32)|(1<<CS30) ;  // fast pwm

  sei();//enable interrupts

}

ISR(TIMER1_COMPA_vect) {


  
    computePID_f(pidZ,1,0.98);

control_f(pidZ.control, PWM_PinZ, D_Pin1Z, D_Pin2Z);

}
ISR(ADC_vect) {//when new ADC value ready



 if (flag == 0){
   
unsigned int lowBitValue = ADCL;                 // младшие биты
  pidZ.fieldm  =   ((ADCH << 8) | lowBitValue); //объединяем старшие биты с младшими
     flag = 1;
 ADMUX = ADMUX & 0b11111000 | flag;

 }
 else{
    
unsigned int lowBitValue = ADCL;                 // младшие биты
 pidZ.refm    =  ((ADCH << 8) | lowBitValue); //объединяем старшие биты с младшими
    flag = 0;
ADMUX = ADMUX & 0b11111000 | flag;
 }

}
void loop() {
 
    // if there's any serial available, read it:

// while (Serial.available() > 0) {
//
//    // look for the next valid integer in the incoming serial stream:
//
//     k = Serial.parseFloat();
//
//    // do it again:
//
//   p = Serial.parseFloat();
//
//    // do it again:
//
//    i = Serial.parseFloat();
//
//     d = Serial.parseFloat();
//    // look for the newline. That's the end of your sentence:
//
//    if (Serial.read() == '\n') {



//    measure_f(pidZ.ref,A_PinZRef,5);
//    measure_f(pidZ.field,A_PinZ,5);
//    if (pidZ.ref >= 700) { //ограничение
//        pidZ.ref = 700;
//    }
//
//
//    computePID_f(pidZ);
//
//control_f(pidZ.control, PWM_PinZ, D_Pin1Z, D_Pin2Z);



//    Serial.println(pidY.control);
//    Serial.println(pidY.field);
Serial.print(pidZ.field);
    Serial.print(" ");
    Serial.print(pidZ.ref);
    Serial.print(" ");
Serial.println(prevData);
//    Serial.print(',');
delay(100);

}



void control_f(int &control, const int pinPWM, const int dir1, const int dir2){

    if (control > 1023)
    { //ограничение сигнала управления сверху
        control = 1023;
        digitalWrite(dir1, HIGH);
        digitalWrite(dir2, LOW);
        analogWrite(pinPWM, control);

    }
    else if((control>=0)&&(control<=1023)){
        digitalWrite(dir1, HIGH);
        digitalWrite(dir2, LOW);
        analogWrite(pinPWM, control);

    }
    else if ((control < 0)&&(control>=(-1023)))
    { //ограничение сигнала управления снизу
        digitalWrite(dir1, LOW);
        digitalWrite(dir2, HIGH);
        analogWrite(pinPWM, abs(control));

    }
    else if (control < -1023)
    { //ограничение сигнала управления сверху
        control = -1023;
        digitalWrite(dir1, LOW);
        digitalWrite(dir2, HIGH);
        analogWrite(pinPWM, abs(control));
    }
    
}

//void measure_f(int &sensorV, const int pin, char num){
//    sensorV = 0;
//    for(char c = 0; c < num; c++){
//        sensorV += analogRead(pin);
//    }
//    sensorV = sensorV/num;
////sensorV = analogRead(pin);
//}

void computePID_f(struct PID_s &pid, float time, float K) {
    pid.control = 0;
    pid.field = pid.prevField*(1-K) + K*pid.fieldm;
    pid.ref = pid.prevRef*(1-0.8) + 0.8*pid.refm;
    
        if (pidZ.ref >= 700) { //ограничение
        pidZ.ref = 700;
    }
    
   pid.diff = (pid.prevField - pid.field)/time; // находим разницу с предыдущим значением (Дифференциальная составляющая)
    prevData = pidZ.field;
    
    pid.prevField = pid.field;
     pid.prevRef = pid.ref;
     
    pid.error = pid.ref - pid.field; // ошибка управления для 8 бит ацп
    
    pid.integral += pid.error;   // чем больше ки тем больше перерегулирование
    //сигнал управления ПИД-регулятора
    pid.control = pid.k*(pid.p*pid.error + pid.i*pid.integral + pid.d*pid.diff);
 /*   pid.control = 0;
    
     pid.error = pid.ref - pid.field; // ошибка управления для 8 бит ацп
     //filters
    pid.field = pid.prevField*(1-K) + K*pid.fieldm;
    pid.ref = pid.prevRef*(1-0.99) + 0.99*pid.refm;
    
        if (pidZ.ref >= 700) { //ограничение
        pidZ.ref = 700;
    }

    
   pid.diff = (pid.error - pid.prevError)/time; // находим разницу с предыдущим значением (Дифференциальная составляющая)
   pid.integral += (pid.error - pid.prevError)*time;   // чем больше ки тем больше перерегулирование
    prevData = pidZ.field;
    
    pid.prevField = pid.field;
     pid.prevRef = pid.ref;
     pid.prevError = pid.error;
   
    

    //сигнал управления ПИД-регулятора
    pid.control = pid.k*(pid.p*pid.error + pid.i*pid.integral + pid.d*pid.diff);*/
}
